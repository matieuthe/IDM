/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.csvmanl.serializer;

import com.google.inject.Inject;
import csvManager.Add;
import csvManager.Condition;
import csvManager.Copy;
import csvManager.Create;
import csvManager.CsvManagerPackage;
import csvManager.Delete;
import csvManager.Exit;
import csvManager.Join;
import csvManager.Load;
import csvManager.Program;
import csvManager.Remove;
import csvManager.Show;
import csvManager.Update;
import csvManager.Where;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.csvmanl.services.CsvManGrammarAccess;

@SuppressWarnings("all")
public class CsvManSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CsvManGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CsvManagerPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CsvManagerPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case CsvManagerPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case CsvManagerPackage.COPY:
				sequence_Copy(context, (Copy) semanticObject); 
				return; 
			case CsvManagerPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case CsvManagerPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case CsvManagerPackage.EXIT:
				sequence_Exit(context, (Exit) semanticObject); 
				return; 
			case CsvManagerPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case CsvManagerPackage.LOAD:
				sequence_Load(context, (Load) semanticObject); 
				return; 
			case CsvManagerPackage.PARAMETER:
				sequence_Parameter(context, (csvManager.Parameter) semanticObject); 
				return; 
			case CsvManagerPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case CsvManagerPackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case CsvManagerPackage.SHOW:
				sequence_Show(context, (Show) semanticObject); 
				return; 
			case CsvManagerPackage.UPDATE:
				sequence_Update(context, (Update) semanticObject); 
				return; 
			case CsvManagerPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Instruction returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (((valeur+=EString valeur+=EString*) | (parameter+=Parameter parameter+=Parameter*)) table=EString)
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (atribut=EString valeur=EString)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.CONDITION__ATRIBUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.CONDITION__ATRIBUT));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.CONDITION__VALEUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.CONDITION__VALEUR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getAtributEStringParserRuleCall_1_0(), semanticObject.getAtribut());
		feeder.accept(grammarAccess.getConditionAccess().getValeurEStringParserRuleCall_3_0(), semanticObject.getValeur());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Copy
	 *     Copy returns Copy
	 *
	 * Constraint:
	 *     (alias=EString table=EString)
	 */
	protected void sequence_Copy(ISerializationContext context, Copy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.COPY__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.COPY__ALIAS));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.COPY__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.COPY__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCopyAccess().getAliasEStringParserRuleCall_2_0(), semanticObject.getAlias());
		feeder.accept(grammarAccess.getCopyAccess().getTableEStringParserRuleCall_4_0(), semanticObject.getTable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Create
	 *     Create returns Create
	 *
	 * Constraint:
	 *     (table=EString colonne+=EString colonne+=EString*)
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     (table=EString where=Where?)
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Exit
	 *     Exit returns Exit
	 *
	 * Constraint:
	 *     {Exit}
	 */
	protected void sequence_Exit(ISerializationContext context, Exit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (table1=EString table2=EString table3=EString)
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.JOIN__TABLE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.JOIN__TABLE1));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.JOIN__TABLE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.JOIN__TABLE2));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.JOIN__TABLE3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.JOIN__TABLE3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJoinAccess().getTable1EStringParserRuleCall_2_0(), semanticObject.getTable1());
		feeder.accept(grammarAccess.getJoinAccess().getTable2EStringParserRuleCall_3_0(), semanticObject.getTable2());
		feeder.accept(grammarAccess.getJoinAccess().getTable3EStringParserRuleCall_5_0(), semanticObject.getTable3());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Load
	 *     Load returns Load
	 *
	 * Constraint:
	 *     (table=EString alias=EString)
	 */
	protected void sequence_Load(ISerializationContext context, Load semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.LOAD__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.LOAD__TABLE));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.LOAD__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.LOAD__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadAccess().getTableEStringParserRuleCall_2_0(), semanticObject.getTable());
		feeder.accept(grammarAccess.getLoadAccess().getAliasEStringParserRuleCall_4_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (colonne=EString value=EString)
	 */
	protected void sequence_Parameter(ISerializationContext context, csvManager.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.PARAMETER__COLONNE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.PARAMETER__COLONNE));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getColonneEStringParserRuleCall_1_0(), semanticObject.getColonne());
		feeder.accept(grammarAccess.getParameterAccess().getValueEStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     instruction+=Instruction*
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     table=EString
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.REMOVE__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.REMOVE__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveAccess().getTableEStringParserRuleCall_2_0(), semanticObject.getTable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Show
	 *     Show returns Show
	 *
	 * Constraint:
	 *     (table=EString (colonne+=EString colonne+=EString*)? where=Where?)
	 */
	protected void sequence_Show(ISerializationContext context, Show semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Update
	 *     Update returns Update
	 *
	 * Constraint:
	 *     (table=EString parameter+=Parameter parameter+=Parameter* where=Where?)
	 */
	protected void sequence_Update(ISerializationContext context, Update semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     (condition+=Condition condition+=Condition*)
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

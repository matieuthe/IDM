/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.csvmanl.serializer;

import com.google.inject.Inject;
import csvManager.Add;
import csvManager.Condition;
import csvManager.Copy;
import csvManager.Create;
import csvManager.CsvManagerPackage;
import csvManager.CsvTable;
import csvManager.Delete;
import csvManager.Exit;
import csvManager.Join;
import csvManager.Load;
import csvManager.Program;
import csvManager.Remove;
import csvManager.Show;
import csvManager.Update;
import csvManager.Where;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.csvmanl.services.CsvManGrammarAccess;

@SuppressWarnings("all")
public class CsvManSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CsvManGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CsvManagerPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CsvManagerPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case CsvManagerPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case CsvManagerPackage.COPY:
				sequence_Copy(context, (Copy) semanticObject); 
				return; 
			case CsvManagerPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case CsvManagerPackage.CSV_TABLE:
				sequence_CsvTable(context, (CsvTable) semanticObject); 
				return; 
			case CsvManagerPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case CsvManagerPackage.EXIT:
				sequence_Exit(context, (Exit) semanticObject); 
				return; 
			case CsvManagerPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case CsvManagerPackage.LOAD:
				sequence_Load(context, (Load) semanticObject); 
				return; 
			case CsvManagerPackage.PARAMETER:
				sequence_Parameter(context, (csvManager.Parameter) semanticObject); 
				return; 
			case CsvManagerPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case CsvManagerPackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case CsvManagerPackage.SHOW:
				sequence_Show(context, (Show) semanticObject); 
				return; 
			case CsvManagerPackage.UPDATE:
				sequence_Update(context, (Update) semanticObject); 
				return; 
			case CsvManagerPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Instruction returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (((valeur+=EString valeur+=EString*) | (parameter+=Parameter parameter+=Parameter*)) csvtable=[CsvTable|EString])
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (colonne=EString valeur=EString)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.CONDITION__COLONNE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.CONDITION__COLONNE));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.CONDITION__VALEUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.CONDITION__VALEUR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getColonneEStringParserRuleCall_1_0(), semanticObject.getColonne());
		feeder.accept(grammarAccess.getConditionAccess().getValeurEStringParserRuleCall_3_0(), semanticObject.getValeur());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Copy
	 *     Copy returns Copy
	 *
	 * Constraint:
	 *     (alias=[CsvTable|ID] table=CsvTable)
	 */
	protected void sequence_Copy(ISerializationContext context, Copy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.COPY__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.COPY__ALIAS));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.COPY__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.COPY__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCopyAccess().getAliasCsvTableIDTerminalRuleCall_2_0_1(), semanticObject.eGet(CsvManagerPackage.Literals.COPY__ALIAS, false));
		feeder.accept(grammarAccess.getCopyAccess().getTableCsvTableParserRuleCall_4_0(), semanticObject.getTable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Create
	 *     Create returns Create
	 *
	 * Constraint:
	 *     csvtable=CsvTable
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.CREATE__CSVTABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.CREATE__CSVTABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateAccess().getCsvtableCsvTableParserRuleCall_2_0(), semanticObject.getCsvtable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CsvTable returns CsvTable
	 *
	 * Constraint:
	 *     (name=EString (colonne+=EString colonne+=EString*)?)
	 */
	protected void sequence_CsvTable(ISerializationContext context, CsvTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     (csvtable=[CsvTable|ID] where=Where?)
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Exit
	 *     Exit returns Exit
	 *
	 * Constraint:
	 *     {Exit}
	 */
	protected void sequence_Exit(ISerializationContext context, Exit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (tables+=[CsvTable|ID] tables+=[CsvTable|ID] table3=CsvTable)
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Load
	 *     Load returns Load
	 *
	 * Constraint:
	 *     (fichier=EString csvtable=CsvTable)
	 */
	protected void sequence_Load(ISerializationContext context, Load semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.LOAD__FICHIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.LOAD__FICHIER));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.LOAD__CSVTABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.LOAD__CSVTABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadAccess().getFichierEStringParserRuleCall_2_0(), semanticObject.getFichier());
		feeder.accept(grammarAccess.getLoadAccess().getCsvtableCsvTableParserRuleCall_4_0(), semanticObject.getCsvtable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (colonne=EString value=EString)
	 */
	protected void sequence_Parameter(ISerializationContext context, csvManager.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.PARAMETER__COLONNE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.PARAMETER__COLONNE));
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getColonneEStringParserRuleCall_1_0(), semanticObject.getColonne());
		feeder.accept(grammarAccess.getParameterAccess().getValueEStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     instruction+=Instruction*
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     csvtable=[CsvTable|ID]
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvManagerPackage.Literals.REMOVE__CSVTABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvManagerPackage.Literals.REMOVE__CSVTABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveAccess().getCsvtableCsvTableIDTerminalRuleCall_2_0_1(), semanticObject.eGet(CsvManagerPackage.Literals.REMOVE__CSVTABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Show
	 *     Show returns Show
	 *
	 * Constraint:
	 *     (csvtable=[CsvTable|ID] (colonne+=EString colonne+=EString*)? where=Where?)
	 */
	protected void sequence_Show(ISerializationContext context, Show semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Update
	 *     Update returns Update
	 *
	 * Constraint:
	 *     (csvtable=[CsvTable|ID] parameter+=Parameter parameter+=Parameter* where=Where?)
	 */
	protected void sequence_Update(ISerializationContext context, Update semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     (condition+=Condition condition+=Condition*)
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

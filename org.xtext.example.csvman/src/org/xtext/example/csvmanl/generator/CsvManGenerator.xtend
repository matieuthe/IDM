/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.csvmanl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import csvManager.Program
import csvManager.Instruction
import csvManager.Show
import csvManager.Load
import csvManager.Create
import csvManager.Where
import java.util.concurrent.locks.Condition
import csvManager.Update
import csvManager.Add
import csvManager.Exit
import csvManager.Delete
import csvManager.Join
import csvManager.Copy
import csvManager.Remove

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CsvManGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('CsvMan.java', resource.allContents.filter(Program).toIterable.head.compile.toString)
	}
	
	def dispatch compile(Program program)
		'''
		import org.apache.commons.csv.CSVFormat;
		import org.apache.commons.csv.CSVParser;
		import org.apache.commons.csv.CSVPrinter;
		import org.apache.commons.csv.CSVRecord;
		
		import java.io.*;
		import java.nio.file.Files;
		import java.nio.file.Paths;
		
		import java.util.*;
		
		public class CsvMan {
		    
		    private Map<String, String> aliasMaps;
		    private String[] paramTab;
		    private int idxParamTab;
		    private String[] conditionTab;
		    private int idxConditionTab;
		
		    public CsvMan(){
		        this.aliasMaps = new HashMap<>();
		        this.paramTab = new String[0];
		        this.conditionTab = new String[0];
		        this.idxParamTab = 0;
		        this.idxConditionTab = 0;
		    }
		
		    public static void main(String[] args){
		    	CsvMan man = new CsvMan();
				«FOR exp: program.instruction»
					«exp.compile»				
				«ENDFOR»
			
		    }
		
		    public void resetParamTab(int length){
		        this.paramTab = new String[length];
		        this.idxParamTab = 0;
		    }
		
		    public void resetConditionTab(int length){
		        this.conditionTab = new String[length];
		        this.idxConditionTab = 0;
		    }
		
		    public void addElmtParamTab(String elmt){
		        this.paramTab[idxParamTab++] = elmt;
		    }
		
		    public void addElmtConditionTab(String elmt){
		        this.conditionTab[idxConditionTab++] = elmt;
		    }
		
		    public String[] getParamTab(){
		        return this.paramTab;
		    }
		
		    public String[] getConditionTab(){
		        return this.conditionTab;
		    }
		
		    /**
		     * Make the link between an alias an a real CSV file
		     * @param alias of the user corresponding to a real CSV that we want to read
		     * @param filename real path to the CSV file
		     */
		    private void putAliasMap(String alias, String filename){
		        String finalAlias = alias;
		        //In case there are file with the same id
		        if(aliasMaps.containsKey(alias)){
		            for(int i = 0; i < 1000; i++){
		                if(!aliasMaps.containsKey(alias + "_" + i)){
		                    finalAlias = alias + "_" + i;
		                    aliasMaps.put(finalAlias, filename);
		                    i = Integer.MAX_VALUE;
		                }
		            }
		        }else{
		            aliasMaps.put(alias, filename);
		        }
		        System.out.println("File " + filename  + " added with alias : " + finalAlias);
		    }
		
		    /**
		     * Return CSVParser on a specific CSV file to read it
		     * @param alias of the user corresponding to a real CSV that we want to read
		     * @exception Exception if CSV file doesn't exist.
		     * @return CSVParser to iterate on CSV file.
		     */
		    private CSVParser getParser(String alias) throws Exception{
		        String fileName = this.aliasMaps.get(alias);
		        if (fileName == null) throw new Exception();
		
		        Reader reader = Files.newBufferedReader(Paths.get(fileName));
		        return new CSVParser(reader, CSVFormat.DEFAULT
		                .withFirstRecordAsHeader()
		                .withIgnoreHeaderCase()
		                .withTrim());
		    }
		
		    /**
		     * Overwrite a CSV File
		     * @param alias of the user corresponding to a real CSV.
		     * @param txt to push in the file.
		     */
		    private void writeIn(String alias, String txt) throws Exception{
		        Writer fileWriter = new FileWriter(this.aliasMaps.get(alias), false); //overwrites file
		        fileWriter.write(txt);
		        fileWriter.flush();
		        fileWriter.close();
		    }
		
		    /**
		     * Return column of a CSV File
		     * @param parser from the lib that allow use to parse efficiently the csv.
		     * @return all columns represented in the CSV file.
		     */
		    private String getHeader(CSVParser parser){
		        Map<String,Integer> headerMap = parser.getHeaderMap();
		        String res = "";
		        for (int i = 0; i < headerMap.size(); i++) {
		            for (String key : headerMap.keySet()) {
		                if (headerMap.get(key) == i) {
		                    res += key;
		                    if (i != headerMap.size() - 1)
		                        res += ",";
		                }
		            }
		        }
		        return res + "\n";
		    }
		
		    /**
		     * Create a new CSV file
		     * @param filename name of the table given by the user. The CSV file will be saved as filename+'.csv'.
		     */
		    public void create(String filename, String...args){
		        try{
		            BufferedWriter writer = Files.newBufferedWriter(Paths.get(filename + ".csv"));
		            CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(args));
		            csvPrinter.flush();
		            this.putAliasMap(filename, filename + ".csv");
		            String columns = "";
		            for(String temp : args) columns += temp + ", ";
		            columns = columns.substring(0, columns.length()-2);
		            System.out.println("File " + filename + ".csv was created with columns : " + columns);
		        } catch (IOException e) {
		            e.printStackTrace();
		        }
		    }
		
		    /**
		     * Load an existing CSV file according to the name given
		     * @param filename path to a real CSV.
		     * @param alias is the name given by the user to the tab.
		     */
		    public void load(String filename, String alias){
		        File tmpFile = new File(filename);
		        if(tmpFile.exists()){
		            this.putAliasMap(alias, filename);
		        }else
		            System.out.println(filename + " doesn't exist");
		    }
		
		    /**
		     * Copy a table and paste it in a new one to duplicate it
		     * @param startFile alias corresponding to a real CSV.
		     * @param arriveFile alias of the copy that will be generated.
		     */
		    public void copy(String startFile, String arriveFile){
		        InputStream inputStream = null;
		        OutputStream outputStream = null;
		        try {
		            inputStream = new FileInputStream(this.aliasMaps.get(startFile));
		            outputStream = new FileOutputStream(arriveFile + ".csv");
		
		            // the size of the buffer doesn't have to be exactly 1024 bytes, try playing around with this number and see what effect it will have on the performance
		            byte[] buffer = new byte[1024];
		            int length = 0;
		            while ((length = inputStream.read(buffer)) > 0) {
		                outputStream.write(buffer, 0, length);
		            }
		            inputStream.close();
		            outputStream.close();
		            System.out.println("File " + startFile + " copied into file " + arriveFile);
		            this.putAliasMap(arriveFile, arriveFile + ".csv");
		        } catch (Exception e) {
		            e.printStackTrace();
		        }
		    }
		
		    /**
		     * Delete a CSV file according to the name given
		     * @param alias alias corresponding to a real CSV.
		     */
		    public void delete(String alias){
		        String fileName = this.aliasMaps.get(alias);
		        if(fileName != null){
		            File file = new File(fileName);
		            if(file.delete()){
		                System.out.println("File " + alias + ".csv deleted");
		                this.aliasMaps.remove(alias);
		                return;
		            }
		        }
		        System.out.println( "Alias " + alias + " doesn't exists");
		    }
		
		    /**
		     * Remove tuple from a CSV file
		     * @param alias alias corresponding to a real CSV.
		     * @param conditions where tuple should be deleted.
		     */
		    public void delete(String alias, String[] conditions){
		        try {
		            String res = "";
		            CSVParser csvParser = this.getParser(alias);
		            Map<String, Integer> headerMap = csvParser.getHeaderMap();
		
		            res += this.getHeader(csvParser);
		
		            //Mise à jour des lignes consernées
		            for (CSVRecord record : csvParser) {
		                boolean b = true;
		                for(int i = 0; i < conditions.length; i+=2){
		                    if(!record.get(conditions[i].trim()).equals(conditions[i+1])){
		                        b = false;
		                        break;
		                    }
		                }
		                //Si la ligne ne remplit pas la condition elle n'est pas recopié dans le nouveau fichier
		                if(!b) {
		                    for (int i = 0; i < record.size(); i++) {
		                        res += record.get(i);
		                        if (i < record.size() - 1) res += ",";
		                    }
		                    res += "\n";
		                }
		            }
		            this.writeIn(alias, res);
		        } catch (Exception e){
		            e.printStackTrace();
		        }
		    }
		
		    /**
		     * Display an entire CSV file
		     * @param alias of the user corresponding to a real CSV that we want to read
		     */
		    public void show(String alias){
		        show(alias, new String[0], new String[0]);
		    }
		
		    /**
		     * Display some column of a CSV file
		     * @param alias of the user corresponding to a real CSV that we want to read
		     * @param selected column name to display
		     */
		    public void show(String alias, String[] selected){
		        show(alias, selected, new String[0]);
		    }
		
		    /**
		     * Display some tuple of some column of a CSV file
		     * @param alias of the user corresponding to a real CSV that we want to read
		     * @param selected column name to display
		     * @param condition to verify to display the tuple
		     */
		    public void show(String alias, String[] selected, String[] condition) {
		        System.out.println("\n");
		
		        boolean printAll = (selected.length == 0);
		        boolean noCondition = (condition.length == 0);
		
		        try {
		            CSVParser csvParser = this.getParser(alias);
		            Map<String, Integer> headerMap = csvParser.getHeaderMap();
		
		            if(printAll){
		                System.out.print(this.getHeader(csvParser));
		
		                for (CSVRecord record : csvParser) {
		                    String res = "";
		                    boolean b = true;
		                    //On vérifie les conditions avant l'affichage
		                    for(int i = 0; i < condition.length; i+=2){
		                        if(!record.get(condition[i].trim()).equals(condition[i+1])){
		                            b = false;
		                            break;
		                        }
		                    }
		                    if(b) {
		                        for (int i = 0; i < record.size() - 1; i++) {
		                            System.out.print(record.get(i) + ",");
		                        }
		                        if (record.size() - 1 >= 0) {
		                            System.out.print(record.get(record.size() - 1));
		                        }
		                        System.out.println();
		                    }
		                }
		            }else{
		                String res = "";
		                //Affichage des entêtes (Header)
		                for(int i = 0; i < selected.length; i++){
		                    if(headerMap.containsKey(selected[i].trim())){
		                        res += selected[i];
		                        if(i < selected.length-1)
		                            res += ",";
		                    }else throw new Exception();
		                }
		
		                System.out.println(res);
		
		                for(CSVRecord record : csvParser) {
		                    boolean b = true;
		                    //On vérifie les conditions avant l'affichage
		                    for(int i = 0; i < condition.length; i+=2){
		                        if(!record.get(condition[i].trim()).equals(condition[i+1])){
		                            b = false;
		                            break;
		                        }
		                    }
		                    if(b) {
		                        for (int i = 0; i < selected.length - 1; i++) {
		                            System.out.print(record.get(selected[i]) + ",");
		                        }
		                        if (selected.length - 1 >= 0) {
		                            System.out.print(record.get(selected[selected.length - 1]));
		                        }
		                        System.out.println();
		                    }
		                }
		
		            }
		            System.out.println("\n");
		
		        } catch (Exception e){
		            e.printStackTrace();
		        }
		
		    }
		
		    /**
		     * Add a tuple in a CSV file at its end
		     * @param parameters giving column name (with elmnt even index) and corresponding value (elmnt with odd idx)
		     * @exception Exception if a given column name doesn't exist.
		     */
		    public void add(String alias, String[] parameters){
		        try {
		            CSVParser csvParser = this.getParser(alias);
		            Map<String, Integer> header = csvParser.getHeaderMap();
		
		            if(parameters.length > header.size())
		                throw new Exception("Ce champ n'existe pas");
		
		            String res = "";
		
		            for(int i = 0; i < parameters.length - 1; i++){
		                if(parameters[i] == null)
		                    res += ",";
		                else
		                    res += parameters[i] + ",";
		            }
		
		            if(parameters.length - 1 >= 0 && parameters[parameters.length -1] != null) res += parameters[parameters.length -1];
		                res+= "\n";
		
		            Writer fileWriter = new FileWriter(this.aliasMaps.get(alias), true); //appended in file
		            fileWriter.write(res);
		            fileWriter.flush();
		            fileWriter.close();
		        }catch (Exception e) {
		            e.printStackTrace();
		        }
		    }
		
		    /**
		     * Add a tuple in a CSV file at its end
		     * @param alias of the user corresponding to a real CSV that we want to read
		     * @param parameter giving column name (with elmnt even index) and corresponding value (elmnt with odd idx)
		     */
		    public void update(String alias, String[] parameter) {
		        this.update(alias, parameter, new String[0]);
		    }
		
		    /**
		     * Add a tuple in a CSV file at its end
		     * @param alias of the user corresponding to a real CSV that we want to read
		     * @param parameter giving column name (with elmnt even index) and corresponding value (elmnt with odd idx)
		     * @param conditions to verify before updating tuples
		     */
		    public void update(String alias, String[] parameter, String[] conditions) {
		
		        //On lit completement le fichier et on le stocke dans un String
		        try {
		            String res = "";
		            CSVParser csvParser = this.getParser(alias);
		
		            Map<String, Integer> headerMap = csvParser.getHeaderMap();
		            String[] cles = new String[headerMap.size()];
		            String[] nValue = new String[headerMap.size()];
		            boolean[] toModify = new boolean[headerMap.size()];
		
		            //Recopie des entêtes
		            for (int i = 0; i < headerMap.size(); i++) {
		                for (String key : headerMap.keySet()) {
		                    if (headerMap.get(key) == i) {
		                        cles[i] = key.trim();
		                        res += key;
		                        if (i != headerMap.size() - 1)
		                            res += ",";
		                    }
		                }
		            }
		            res+= "\n";
		
		            for(int i = 0; i < parameter.length; i+=2){
		                for(int j = 0; j < cles.length; j++){
		                    if(cles[j].equals(parameter[i])){
		                        toModify[j] = true;
		                        nValue[j] = parameter[i+1];
		                    }
		                }
		            }
		
		            //Mise à jour des lignes consernées
		            for (CSVRecord record : csvParser) {
		                boolean b = true;
		                for(int i = 0; i < conditions.length; i+=2){
		                    if(!record.get(conditions[i].trim()).equals(conditions[i+1])){
		                        b = false;
		                        break;
		                    }
		                }
		
		                for(int i = 0; i < record.size(); i++){
		                    if(toModify[i] && b){
		                        res += nValue[i];
		                    }else{
		                        res += record.get(i);
		                    }
		                    if(i < record.size()-1) res += ",";
		                }
		                res += "\n";
		            }
		            //Write the res in the file
		            this.writeIn(alias, res);
		        } catch (Exception e){
		            e.printStackTrace();
		        }
		    }
		
		    /**
		     * Join 2 CSV file in a new file
		     * @param alias1 of the first table of user
		     * @param alias2 of the second table of user
		     * @param toAlias of the table that will be generated with the result content
		     */
		    public void join(String alias1, String alias2, String toAlias) {
		        try {
		            CSVParser csvParser1 = this.getParser(alias1);
		            CSVParser csvParser2 = this.getParser(alias2);
		
		            String res = "";
		            Map<String, Integer> headerMap1 = csvParser1.getHeaderMap();
		            Map<String, Integer> headerMap2 = csvParser2.getHeaderMap();
		
		            String colomnToJoin = "";
		
		            for (String k : headerMap1.keySet()) {
		                if (headerMap2.containsKey(k)) {
		                    colomnToJoin = k;
		                }
		            }
		
		            if (!colomnToJoin.isBlank()) {
		                res += this.getHeader(csvParser1);
		                res = res.replace("\n", "");
		                res += ',';
		                String tmp = this.getHeader(csvParser2).replace(colomnToJoin + ",", "").replace("," + colomnToJoin, "");
		                res += tmp;
		                create(toAlias, res);
		                res = "";
		
		                List<CSVRecord> records2 = csvParser2.getRecords();
		
		                //On parcourt la premiere table
		                for (CSVRecord record : csvParser1) {
		                    String joinValueTab1 = record.get(headerMap1.get(colomnToJoin));
		
		                    //On parcourt la premiere table
		                    for (CSVRecord record2 : records2) {
		                        String joinValueTab2 = record2.get(headerMap2.get(colomnToJoin));
		
		                        //Join accepted for this tuple
		                        if(joinValueTab1.equals(joinValueTab2)){
		
		                            for(int i = 0; i < record.size(); i++){
		                                res += record.get(i);
		                                res += ",";
		                            }
		                            for(int i = 0; i < record2.size(); i++){
		                                if(i!=headerMap2.get(colomnToJoin)) {
		                                    res += record2.get(i);
		                                    if(i < record2.size()-1) res+= ",";
		                                }
		                            }
		                            res += "\n";
		                        }
		                    }
		                }
		                this.writeIn(toAlias, res);
		                show(toAlias);
		
		            } else {
		                throw new Exception("Can't join those tables : no column in common !");
		            }
		        } catch (Exception e) {
		            e.printStackTrace();
		        }
		    }
		}'''
		
		/*
		 * Load Function
		 */
		def dispatch compile(Load load)
			'''
				man.load("«load.fichier»", "«load.csvtable.name»");
			'''
		
		/*
		 * Create Function
		 */
		def dispatch compile(Create created)
			'''
				man.resetParamTab(«created.csvtable.colonne.length»);
				«FOR exp: created.csvtable.colonne»
					man.addElmtParamTab("«exp»");
				«ENDFOR»
				man.create("«created.csvtable.name»", man.getParamTab());
			'''
		
				
		/*
		 * Show function
		 */
		def dispatch compile(Show show)
			'''
				man.resetParamTab(«show.colonne.length»);
				man.resetConditionTab(0);
				«FOR exp: show.colonne»
					man.addElmtParamTab("«exp»");
				«ENDFOR»
				«IF show.where !== null»
					«show.where.compile»
				«ENDIF»
				man.show("«show.csvtable.name»", man.getParamTab(), man.getConditionTab());
			'''
		
		/*
		 * Update function
		 */
		def dispatch compile(Update update)
			'''
				man.resetParamTab(«update.parameter.length»*2);
				man.resetConditionTab(0);
				«FOR exp: update.parameter»
					man.addElmtParamTab("«exp.colonne»");
				«ENDFOR»
				«IF update.where !== null»
					«update.where.compile»
				«ENDIF»
				man.update("«update.csvtable.name»", man.getParamTab(), man.getConditionTab());
			'''		 
		
		/*
		 * Add
		 */
		 def dispatch compile(Add add)
			'''
				«IF add.valeur.length > 0»
					man.resetParamTab(«add.valeur.length»);
					«FOR exp: add.valeur»
						man.addElmtParamTab("«exp»");
					«ENDFOR»
					man.add("«add.csvtable.name»", man.getParamTab());				
				«ELSE»
					man.resetParamTab(«add.parameter.length» * 2);
					«FOR exp: add.parameter»
						man.addElmtParamTab("«exp.colonne»");
						man.addElmtParamTab("«exp.value»");					
					«ENDFOR»
					man.addParameterized("«add.csvtable.name»", man.getParamTab());	
					
				«ENDIF»				
			'''		 
		 
		/*
		 * EXIT
		 */
		def dispatch compile(Copy copy)
			'''
				man.copy("«copy.alias.name»", "«copy.table.name»");
			'''		
				
		/*
		 * EXIT
		 */
		def dispatch compile(Exit exit)
			'''
				return;
			'''		
		 
		/*
		 * Delete function
		 */
		def dispatch compile(Delete delete)
			'''
				«IF delete.where !== null»
					«delete.where.compile»
					man.delete("«delete.csvtable.name»", man.getConditionTab());
				«ELSE»
					man.delete("«delete.csvtable.name»");
				«ENDIF»
			'''		
		
				 
		/*
		 * Join function
		 */
		def dispatch compile(Join join)
			'''
				man.join("«join.tables.get(0)»", "«join.tables.get(1)»", "«join.table3»");
			'''			
		
		/*
		 * Remove function
		 */
		def dispatch compile(Remove remove)
			'''
				man.remove("«remove.csvtable.name»");
			'''		
		
		def dispatch compile(Where where)
		'''
			man.resetConditionTab(«where.condition.length»*2);
			«FOR exp: where.condition»
				man.addElmtConditionTab("«exp.colonne»");
				man.addElmtConditionTab("«exp.valeur»");
			«ENDFOR»
		'''

		
	def dispatch compile(Instruction instruction)
		'''
		'''
		

}
